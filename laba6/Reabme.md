Вариант 3. Дробный рюкзак с жадным алгоритмом
Задача: реализовать жадный алгоритм для дробного рюкзака. Сортировка предметов по
удельной стоимости (value/weight).
Требования:
- Считать предметы как объекты с весом и стоимостью
- Вместимость рюкзака задается как параметр
- Вывести максимальную стоимость и набор предметов

 алгоритм:

Создаем класс Item для хранения веса и стоимости предмета

Вычисляем удельную стоимость для каждого предмета (value/weight)

Сортируем предметы по убыванию удельной стоимости

Проходим по отсортированным предметам:

Если предмет помещается целиком - берем его полностью

Если не помещается - берем дробную часть

Выводим результат - максимальную стоимость и набор выбранных предметов



Временная сложность:
Самый медленный этап - сортировка, поэтому общая сложность O(n log n)



Контрольный вопрос:
Вот код, который нужно дописать в указанном месте:

cpp
vector<int> twoOpt(vector<int> path, const vector<vector<int>>& dist) {
    bool improved = true;
    while (improved) {
        improved = false;
        for (int i = 1; i < path.size() - 2; i++) {
            for (int j = i + 1; j < path.size() - 1; j++) {
                // ДОПИСАТЬ: проверить, улучшает ли обмен (i,j) длину маршрута
                
                // Рассчитываем разницу длин до и после обмена
                int current_cost = dist[path[i-1]][path[i]] + dist[path[j]][path[j+1]];
                int new_cost = dist[path[i-1]][path[j]] + dist[path[i]][path[j+1]];
                
                // Если новый маршрут короче, выполняем обмен
                if (new_cost < current_cost) {
                    // Разворачиваем сегмент между i и j
                    reverse(path.begin() + i, path.begin() + j + 1);
                    improved = true;
                }
            }
        }
    }
    return path;
}
