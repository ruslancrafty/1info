Алгоритмы сортировки
1. Блочная (корзинная) сортировка (Bucket Sort)
1. Определение алгоритма
Алгоритм распределяет элементы входного массива по нескольким "корзинам" (блокам) в зависимости от их значений. Затем каждая корзина сортируется отдельно (часто алгоритмом сортировки вставками), после чего отсортированные корзины объединяются в итоговый массив.

4. Объяснение работы алгоритма
Алгоритм работает в несколько этапов:

Создаётся пустой список корзин.

Каждый элемент массива помещается в одну из корзин, определяемую по формуле index = value * n / (max_value + 1).

Каждая непустая корзина сортируется индивидуально.

Элементы из всех корзин последовательно добавляются в результирующий массив.

5. Оценка временной сложности

В лучшем случае: O(n + k)

В среднем случае: O(n + k)

В худшем случае: O(n²)

6. Объяснение оценки сложности

Лучший/Средний случай: Возникает при равномерном распределении элементов по корзинам. Время распределения элементов O(n), а сортировка k корзин вставками занимает O(k * (n/k)²) ≈ O(n²/k), что в сумме даёт O(n) при оптимальном k.

Худший случай: Происходит, когда все элементы попадают в одну корзину, и их сортировка вставками занимает O(n²).

2. Блинная сортировка (Pancake Sort)
1. Определение алгоритма
Алгоритм сортирует массив, используя только одну операцию — переворот префикса массива (подмассива от начала до выбранного индекса).

4. Объяснение работы алгоритма
Основные шаги алгоритма:

В неотсортированной части массива находится индекс максимального элемента (mi).

Переворачивается подмассив от начала до mi, чтобы максимальный элемент оказался на первом месте.

Переворачивается вся неотсортированная часть массива, чтобы максимальный элемент переместился в её конец.

Процесс повторяется для оставшейся неотсортированной части.

5. Оценка временной сложности

O(n²)

6. Объяснение оценки сложности
Алгоритм выполняет до O(n) переворотов, каждый из которых может требовать до O(n) операций. Таким образом, общая сложность составляет O(n²).

3. Сортировка бусинами (Bead Sort)
1. Определение алгоритма
Алгоритм имитирует падение бусин под действием гравиации на стержнях абака. Количество бусин в строке соответствует значению элемента.

4. Объяснение работы алгоритма

Создаётся матрица, где строки представляют числа, а столбцы — разряды.

"Бусины" (единицы) падают вниз под действием "гравиации".

После падения бусин количество их в каждой строке снизу вверх даёт отсортированную последовательность.

5. Оценка временной сложности

O(n) (теоретически)

O(S), где S — сумма всех элементов (практически)

6. Объяснение оценки сложности
Теоретически время линейно, так как зависит от количества операций "падения" бусин. Однако на практике реализация требует O(S) операций, где S — сумма элементов массива, что для больших чисел может быть значительным.

Алгоритмы поиска
4. Поиск скачками (Jump Search)
1. Определение алгоритма
Алгоритм работает на отсортированном массиве, "прыгая" вперёд на фиксированный шаг для быстрого сужения диапазона, после чего в найденном блоке выполняется линейный поиск.

4. Объяснение работы алгоритма

Определяется размер прыжка step = sqrt(n).

Выполняются прыжки через step элементов, пока не будет найден элемент, больший или равный целевому.

В найденном блоке выполняется линейный поиск от предыдущего прыжка до текущего.

5. Оценка временной сложности

O(√n)

6. Объяснение оценки сложности
Оптимальный размер прыжка — √n. В худшем случае потребуется n/√n = √n прыжков и √n сравнений при линейном поиске, что в сумме даёт O(√n).

5. Экспоненциальный поиск (Exponential Search)
1. Определение алгоритма
Алгоритм быстро находит диапазон, содержащий искомый элемент, экспоненциально увеличивая границы поиска, после чего применяет бинарный поиск в этом диапазоне.

4. Объяснение работы алгоритма

Если первый элемент не искомый, граница поиска удваивается: 1, 2, 4, 8, ... пока не будет превышен целевой элемент.

На найденном диапазоне [prev, min(high, n-1)] выполняется стандартный бинарный поиск.

5. Оценка временной сложности

O(log n)

6. Объяснение оценки сложности
Экспоненциальное увеличение границ занимает O(log i) времени, где i — индекс элемента. Бинарный поиск на диапазоне размером O(i) занимает O(log i). Итоговая сложность — O(log i), что для всего массива равно O(log n).

6. Тернарный поиск (Ternary Search)
1. Определение алгоритма
Алгоритм делит область поиска на три части и рекурсивно выбирает ту из них, где может находиться целевой элемент.

4. Объяснение работы алгоритма

Диапазон [l, r] делится на три части двумя точками: mid1 = l + (r - l) / 3 и mid2 = r - (r - l) / 3.

Целевое значение сравнивается с элементами в mid1 и mid2.

В зависимости от результатов сравнения поиск продолжается в одной из трёх частей.

5. Оценка временной сложности

O(log₃ n)

6. Объяснение оценки сложности
На каждом шаге размер области поиска уменьшается в 3 раза. Количество шагов, необходимых для уменьшения до 1 элемента, равно log₃ n, что даёт логарифмическую сложность.


