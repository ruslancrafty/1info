Алгоритмы сортировки
1. Блочная (корзинная) сортировка (Bucket Sort)
1. Определение алгоритма
Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.

4. Объяснение работы алгоритма
Алгоритм работает в несколько этапов:

Создаётся пустой список корзин.

Каждый элемент массива помещается в одну из корзин, определяемую по формуле index = value * n / (max_value + 1).

Каждая непустая корзина сортируется индивидуально.

Элементы из всех корзин последовательно добавляются в результирующий массив.

5. Оценка временной сложности

В лучшем случае: O(n + k)

В среднем случае: O(n + k)

В худшем случае: O(n²)

6. Объяснение оценки сложности
Такая сложность возникает из-за:

Лучший случай: равномерного распределения элементов по корзинам

Худший случай: попадания всех элементов в одну корзину, что вырождает алгоритм в сортировку вставками

2. Блинная сортировка (Pancake Sort)
1. Определение алгоритма
Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

4. Объяснение работы алгоритма
Основные шаги алгоритма:

В неотсортированной части массива находится индекс максимального элемента (mi).

Переворачивается подмассив от начала до mi, чтобы максимальный элемент оказался на первом месте.

Переворачивается вся неотсортированная часть массива, чтобы максимальный элемент переместился в её конец.

Процесс повторяется для оставшейся неотсортированной части.

5. Оценка временной сложности

O(n²)

6. Объяснение оценки сложности
Такая сложность возникает из-за:

необходимости выполнения O(n) переворотов массива

того, что каждый переворот требует O(n) операций

3. Сортировка бусинами (гравитационная) (Bead Sort)
1. Определение алгоритма
Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации.

4. Объяснение работы алгоритма

Создаётся матрица, где строки представляют числа, а столбцы — разряды.

"Бусины" (единицы) падают вниз под действием "гравиации".

После падения бусин количество их в каждой строке снизу вверх даёт отсортированную последовательность.

5. Оценка временной сложности

O(n) (теоретически)

O(S), где S — сумма всех элементов (практически)

6. Объяснение оценки сложности
Такая сложность возникает из-за:

Теоретически: линейной зависимости от количества элементов

Практически: необходимости обработки каждой "бусины" отдельно

Алгоритмы поиска
4. Поиск скачками (Jump Search)
1. Определение алгоритма
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через √n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.

4. Объяснение работы алгоритма

Определяется размер прыжка step = sqrt(n).

Выполняются прыжки через step элементов, пока не будет найден элемент, больший или равный целевому.

В найденном блоке выполняется линейный поиск от предыдущего прыжка до текущего.

5. Оценка временной сложности

O(√n)

6. Объяснение оценки сложности
Такая сложность возникает из-за:

оптимального размера прыжка √n

выполнения O(√n) прыжков и O(√n) сравнений в блоке

5. Экспоненциальный поиск (Exponential Search)
1. Определение алгоритма
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.

4. Объяснение работы алгоритма

Если первый элемент не искомый, граница поиска удваивается: 1, 2, 4, 8, ... пока не будет превышен целевой элемент.

На найденном диапазоне [prev, min(high, n-1)] выполняется стандартный бинарный поиск.

5. Оценка временной сложности

O(log n)

6. Объяснение оценки сложности
Такая сложность возникает из-за:

экспоненциального увеличения границ за O(log i)

применения бинарного поиска за O(log i)

6. Тернарный поиск (Ternary Search)
1. Определение алгоритма
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции.

4. Объяснение работы алгоритма

Диапазон [l, r] делится на три части двумя точками: mid1 = l + (r - l) / 3 и mid2 = r - (r - l) / 3.

Целевое значение сравнивается с элементами в mid1 и mid2.

В зависимости от результатов сравнения поиск продолжается в одной из трёх частей.

5. Оценка временной сложности

O(log₃ n)

6. Объяснение оценки сложности
Такая сложность возникает из-за:

деления диапазона на три части на каждом шаге

уменьшения поискового пространства в 3 раза на каждой итерации
