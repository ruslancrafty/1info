Алгоритм:
Инициализация: Случайно распределяем задачи по машинам

Локальный поиск: На каждой итерации:

Выбираем случайную задачу

Пробуем переложить её на каждую другую машину

Вычисляем новый makespan (максимальную загрузку)

Если makespan улучшился, принимаем изменение

Критерий остановки: Алгоритм выполняется заданное количество итераций  
........  
Инициализация: Случайное распределение  

assignment[i] = (int) (Math.random() * m);  
Локальный поиск: Выбор случайной задачи  

int taskIdx = (int) (Math.random() * n);  
Локальный поиск: Перебор всех других машин  

for (int newMachine = 0; newMachine < m; newMachine++) {  
    if (newMachine == currentMachine) continue;  
Локальный поиск: Вычисление нового makespan  

int newMakespan = getMakespan(newLoad);  
Локальный поиск: Принятие улучшения  

if (newMakespan < currentMakespan) {  
Критерий остановки: Фиксированное число итераций  

for (int iter = 0; iter < maxIter; iter++) {  
.........
Временная сложность O(maxIter × n × m) возникает потому, что алгоритм выполняет maxIter итераций, на каждой из которых для одной из n задач проверяет возможность перемещения на каждую из m машин.  
................  
Формула критерия Метрополиса:  
P = exp(-ΔE / T), где вероятность перехода в худшее состояние определяется как:  
переход принимается, если random(0,1) < exp(-ΔE / T).  

Что это означает:  

ΔE — ухудшение целевой функции (например, увеличение makespan)  

T — текущая «температура» (параметр, уменьшающийся со временем)  

exp(-ΔE / T) — вероятность принять ухудшение:  

При высокой T вероятность велика (можно активно исследовать пространство)  

При низкой T вероятность мала (алгоритм ближе к жадному поиску)  

Таким образом, критерий позволяет выходить из локальных минимумов за счёт вероятностного принятия худших решений на ранних этапах.  
