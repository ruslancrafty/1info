Анализ алгоритма: Сортировка выбора (Selection Sort)
Определение:
Сортировка выбора (Selection Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом этапе он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом неотсортированной части.

Анализ:
Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.

Внешний цикл for выполняется n-1 раз.
Внутренний цикл for в процессе работы выполняет n-1, затем n-2, ..., раз за каждый проход внешнего цикла.
Общее количество сравнений примерно равно n*(n-1)/2.

Временная сложность: O(n²)

Почему O(n²): Два вложенных цикла, где каждый из них в худшем случае зависит от n. Внутренний цикл может выполняться до n раз для каждой из n итераций внешнего цикла, что создает квадратичную зависимость.

Анализ алгоритма: Сортировка пузырьком (Bubble Sort)
Определение:
Сортировка пузырьком (Bubble Sort) — это алгоритм, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке.

Анализ:
Алгоритм последовательно сравнивает пары соседних элементов и выполняет обмен, если они расположены в неправильном порядке.

Внешний цикл for выполняется n раз.
Внутренний цикл for в процессе работы выполняет n-1, затем n-2, ..., раз за каждый проход внешнего цикла.
Общее количество сравнений примерно равно n*(n-1)/2.

Временная сложность: O(n²)

Почему O(n²): Два вложенных цикла, где каждый из них в худшем случае зависит от n. Внутренний цикл может выполняться до n раз для каждой из n итераций внешнего цикла, что создает квадратичную зависимость.

Анализ алгоритма: Сортировка вставками (Insertion Sort)
Определение:
Сортировка вставками (Insertion Sort) — это алгоритм, который строит отсортированную последовательность постепенно, на каждом шаге вставляя очередной элемент в правильную позицию внутри уже отсортированной части массива.

Анализ:
Алгоритм последовательно берет каждый элемент из неотсортированной части и вставляет его в правильную позицию внутри отсортированной части.

Внешний цикл for выполняется n-1 раз.
Внутренний цикл while в худшем случае может выполнять до i сравнений и сдвигов для каждой итерации внешнего цикла.
Общее количество операций в худшем случае примерно равно n*(n-1)/2.

Временная сложность: O(n²)

Почему O(n²): В худшем случае для каждого из n элементов внутренний цикл может выполнять до n операций, что создает квадратичную зависимость.

Анализ алгоритма: Сортировка слиянием (Merge Sort)
Определение:
Сортировка слиянием (Merge Sort) — это алгоритм "разделяй и властвуй", который рекурсивно разделяет массив на две половины, сортирует каждую из них, а затем объединяет отсортированные половины.

Анализ:
Алгоритм рекурсивно разделяет массив пополам до тех пор, пока не останутся подмассивы размером 1 элемент, затем объединяет их в отсортированном порядке.

Рекурсивная функция mergeSort вызывает себя дважды для левой и правой половин массива.
Функция merge объединяет два отсортированных подмассива за линейное время.
Глубина рекурсии составляет примерно log₂n уровней.

Временная сложность: O(n log n)

Почему O(n log n): На каждом уровне рекурсии выполняется операция слияния с сложностью O(n), а всего уровней рекурсии примерно log₂n.

Анализ алгоритма: Сортировка Шелла (Shell Sort)
Определение:
Сортировка Шелла (Shell Sort) — это алгоритм, который является обобщением сортировки вставками. Он сортирует элементы, расположенные на определенном расстоянии друг от друга, постепенно уменьшая это расстояние до 1.

Анализ:
Алгоритм использует последовательность промежутков (gaps), начиная с большого расстояния и уменьшая его до 1. На каждом промежутке выполняется сортировка вставками для элементов, находящихся на этом расстоянии.

Внешний цикл while выполняется для каждого промежутка в последовательности.
Внутренний цикл for проходит по элементам массива, начиная с позиции gap.
Вложенный цикл while выполняет вставку элемента в отсортированную подпоследовательность.

Временная сложность: Зависит от выбранной последовательности промежутков

В худшем случае: O(n²)

В лучшем случае: O(n log n)

В среднем случае: O(n^(3/2))

Почему такая сложность: Производительность сильно зависит от выбранной последовательности промежутков.

Анализ алгоритма: Быстрая сортировка (Quick Sort)
Определение:
Быстрая сортировка (Quick Sort) — это алгоритм "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного, затем рекурсивно сортирует эти части.

Анализ:
Алгоритм выбирает опорный элемент и распределяет остальные элементы в две группы: меньшие или равные опорному и большие опорного.

Рекурсивная функция quick_sort вызывает себя для левой и правой частей массива.
На каждом уровне рекурсии выполняется проход по всем элементам массива для разделения на подмассивы.
В среднем случае массив делится примерно пополам на каждом уровне рекурсии.

Временная сложность:

В среднем случае: O(n log n)

В худшем случае: O(n²)

Почему O(n log n) в среднем: На каждом уровне рекурсии выполняется O(n) операций для разделения массива, а количество уровней рекурсии составляет O(log n) при равномерном разделении.

Почему O(n²) в худшем случае: Если опорный элемент всегда оказывается минимальным или максимальным, массив делится на части размером 1 и n-1, что приводит к n уровням рекурсии с O(n) операциями на каждом уровне.

Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
Определение:
Пирамидальная сортировка (Heap Sort) — это алгоритм, который использует структуру данных "двочная куча" (binary heap) для сортировки элементов. Алгоритм строит max-heap из массива и последовательно извлекает максимальный элемент.

Анализ:
Алгоритм состоит из двух основных этапов: построение max-heap и последовательное извлечение элементов.

Функция heapify поддерживает свойство кучи для поддерева.
Первый цикл for строит max-heap, вызывая heapify для всех нелистовых узлов.
Второй цикл for извлекает элементы из кучи, перемещая корень в конец и восстанавливая свойство кучи для уменьшенного массива.

Временная сложность: O(n log n)

Почему O(n log n): Построение кучи выполняется за O(n) операций, а каждый из n вызовов heapify выполняется за O(log n) времени, так как высота двоичной кучи составляет log n.

Анализ алгоритма: Линейный поиск (Linear Search)
Определение:
Линейный поиск (Linear Search) — это алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

Анализ:
Алгоритм проходит по всем элементам массива от начала до конца, сравнивая каждый элемент с целевым значением.

Цикл for выполняется от первого до последнего элемента массива.
На каждой итерации выполняется сравнение текущего элемента с целевым значением.
В лучшем случае алгоритм находит элемент на первой позиции, в худшем — на последней или не находит вовсе.

Временная сложность: O(n)

Почему O(n): В худшем случае алгоритму необходимо проверить все n элементов массива. В среднем случае проверяется примерно n/2 элементов.

Анализ алгоритма: Бинарный поиск (Binary Search)
Определение:
Бинарный поиск (Binary Search) — это алгоритм поиска, который работает на отсортированном массиве и многократно делит интервал поиска пополам, сравнивая средний элемент с целевым значением.

Анализ:
Алгоритм начинает поиск со всего массива и на каждом шаге уменьшает интервал поиска в два раза.

Цикл while выполняется до тех пор, пока интервал поиска не сократится до нуля.
На каждой итерации вычисляется средний элемент интервала и сравнивается с целевым значением.
В зависимости от результата сравнения поиск продолжается в левой или правой половине интервала.

Временная сложность: O(log n)

Почему O(log n): На каждом шаге алгоритм уменьшает область поиска в два раза. Максимальное количество шагов, необходимое для нахождения элемента, равно log₂n, где n — размер массива.

Анализ алгоритма: Интерполяционный поиск (Interpolation Search)
Определение:
Интерполяционный поиск (Interpolation Search) — это алгоритм поиска в отсортированном массиве, который использует значения элементов для оценки вероятного положения искомого элемента.

Анализ:
Алгоритм вычисляет предполагаемую позицию элемента на основе значения целевого элемента и значений на границах интервала поиска.

Цикл while выполняется до тех пор, пока интервал поиска не сократится до нуля и целевой элемент находится в пределах текущего интервала.
На каждой итерации вычисляется предполагаемая позиция с использованием интерполяционной формулы.
В зависимости от результата сравнения поиск продолжается в левой или правой части интервала.

Временная сложность:

В среднем случае: O(log log n)

В худшем случае: O(n)

Почему O(log log n) в среднем: Алгоритм эффективно сокращает область поиска на каждом шаге, особенно при равномерном распределении элементов, что приводит к логарифмическому от логарифма времени выполнения.

Почему O(n) в худшем случае: При неравномерном распределении элементов алгоритм может деградировать до линейного поиска, если элементы распределены неравномерно.

Анализ алгоритма: Поиск Фибоначчи (Fibonacci Search)
Определение:
Поиск Фибоначчи (Fibonacci Search) — это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения позиций сравнения и деления массива.

Анализ:
Алгоритм генерирует последовательность Фибоначчи до тех пор, пока не найдет число, большее или равное размеру массива.
Затем алгоритм использует числа Фибоначчи для определения позиций сравнения в массиве.

Первый цикл while генерирует числа Фибоначчи до достижения нужного размера.
Второй цикл while выполняет поиск, используя числа Фибоначчи для определения позиций сравнения.
На каждой итерации алгоритм сокращает область поиска на основе сравнения элемента в вычисленной позиции с целевым значением.

Временная сложность: O(log n)

Почему O(log n): Алгоритм делит массив на части, используя числа Фибоначчи, что обеспечивает логарифмическое время выполнения аналогично бинарному поиску, но с другим способом определения средней точки.
