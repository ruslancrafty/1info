Анализ алгоритма: Сортировка выбора (Selection Sort) Определение: Сортировка выбора (Selection Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом этапе он находит элемент в неотсортированной части и меняет его места с первым элементом неотсортированной части.

Анализ: Алгоритм находит элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.

Внешний цикл на достижения n-1 раз. Внутренний цикл в процессе работы выполняет n-1, затем n-2, ..., раз за каждый проход внешнего цикла. Общее количество сравнений примерно равно n*(n-1)/2.

Временная сложность: O(n²)

Почему O(n²): Два вложенных цикла, где каждый из них в исходном состоянии зависит от n. Внутренний цикл может выполняться до n раз для каждой из n итераций внешнего цикла, создающих квадратичную зависимость.

Анализ алгоритма: Сортировка пузырьком (Bubble Sort) Определение: Сортировка пузырьком (Bubble Sort) — это алгоритм, который многократно проходит по массиву, сравнивает соседние элементы и меняет их местами, если они перемещаются в неправильном порядке.

Анализ: Алгоритм последовательно сравнивает пары удалений и обмен, если они расположены в неправильном порядке.

Внешний цикл для достижения результата n раз. Внутренний цикл в процессе работы выполняет n-1, затем n-2, ..., раз за каждый проход внешнего цикла. Общее количество сравнений примерно равно n*(n-1)/2.

Временная сложность: O(n²)

Почему O(n²): Два вложенных цикла, где каждый из них в исходном состоянии зависит от n. Внутренний цикл может выполняться до n раз для каждой из n итераций внешнего цикла, создающих квадратичную зависимость.

Анализ алгоритма: Сортировка вставками (Сортировка вставками) Определение: Сортировка вставками (Сортировка вставками) — это алгоритм, который строит отсортированную последовательность последовательно, на каждом шаге выдерживая очередной элемент в правильной позиции внутри уже отсортированной части массива.

Анализ: Алгоритм последовательно берет каждый элемент из неотсортированной части и помещает его в правильную позицию внутри отсортированной части.

Внешний цикл на достижения n-1 раз. Внутренний цикл в режиме реального времени может выполнять сравнения и этапы для каждой итерации внешнего цикла. Общее количество операций в режиме реального времени примерно равно n*(n-1)/2.

Временная сложность: O(n²)

Почему O(n²): В базовом случае для каждого из n элементов внутренний цикл может выполняться до n операций, что создает квадратичную зависимость.

Анализ алгоритма: Сортировка слиянием (Merge Sort) Определение: Сортировка слиянием (Merge Sort) — это алгоритм «разделяй и властвуй», который рекурсивно разделяет массив на две половины, сортирует каждую из них, а затем выбирает отсортированные половины.

Анализ: Алгоритм рекурсивно разделяет массив пополам до тех пор, пока не найдены подмассивы размером 1 элемент, а затем сортирует их в отсортированном порядке.

Рекурсивная функция mergeSort вызывает себя дважды для левой и правой половинки массива. Функция слияния двух отсортированных подмассивов по линейному времени. Глубина рекурсии составляет примерно log₂n уровней.

Временная сложность: O(n log n)

O(n log n): На каждом уровне рекурсии достигается операция слияния с сложностью O(n), а всего уровней рекурсии, почему примерно log₂n.

Анализ алгоритма: Сортировка Шелла (Shell Sort) Определение: Сортировка Шелла (Shell Sort) — это алгоритм, который является обобщением сортировки вставок. Он сортирует элементы, расположенные на расстоянии друг от друга, постепенно уменьшая это расстояние до 1.

Анализ: Алгоритм использует последовательность промежутков (промежутков), начиная с большего расстояния и уменьшая его до 1. На каждой промежутке выполняется сортировка вставок для элементов, находящихся на этом расстоянии.

Внешний цикл пока результат каждого промежутка в последовательности. Внутренний цикл для прохождения по элементам массива, начиная с позиции пробела. Вложенный цикл во время выполнения вставки элемента в отсортированную подпоследовательность.

Временная сложность: Зависит от выбранной последовательности промежутков.

В худшем случае: O(n²)

В лучшем случае: O(n log n)

В среднем случае: O(n^(3/2))

Почему такая сложность: Производительность сильно зависит от выбранной последовательности промежутков.

Анализ алгоритма: Быстрая сортировка (Quick Sort) Определение: Быстрая сортировка (Quick Sort) — это алгоритм «разделяй и властвуй», который выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного, затем рекурсивно сортирует эти части.

Анализ: Алгоритм выбирает опорный элемент и возвращает остальные элементы в две группы: меньшие или равные опорному и больше опорному.

Рекурсивная функция fast_sort вызывает себя для левой и правой частей массива. На каждом уровне рекурсии достигается проход по всем элементам массива для разделения на подмассивы. В среднем случае массив примерно пополам на каждом уровне рекурсии.

Временная сложность:

В среднем случае: O(n log n)

В худшем случае: O(n²)

O(n log n) в среднем: на каждом уровне рекурсии результат O(n) операций для разделения массива, а количество уровней, почему рекурсии составляет O(log n) при равномерном разделении.

O(n²) в более простом случае: если опорный элемент всегда оказывается выступающим или максимальным, массив делится на части размером 1 и почему n-1, что приводит к n уровням рекурсии с O(n) операциями на каждом уровне.

Анализ алгоритма: Пирамидальная сортировка (кучная сортировка) Определение: Пирамидальная сортировка (кучная сортировка) — это алгоритм, который использует структуру данных «двойная куча» (двоичная куча) для сортировки элементов. Алгоритм создает максимальную кучу из массива и последовательно извлекает максимальный элемент.

Анализ: Алгоритм составления из двух основных этапов: построение максимальной кучи и последовательное извлечение элементов.

Функция heapify поддерживает функцию кучи для поддерева. Первый цикл построения max-heap, вызывающий heapify для всех нелистовых узлов. Второй цикл для извлечения элементов из кучи, перемещения ядра в конец и изменения свойства кучи для уменьшенного массива.

Временная сложность: O(n log n)

Почему O(n log n): Построение кучи показателей для O(n) операций, а каждый из n вызовов увеличивает результат за O(log n) времени, так как высота двойной кучи составляет log n.

Анализ алгоритма: Линейный поиск (Linear Search) Определение: Линейный поиск (Linear Search) — это алгоритм поиска, который последовательно каждый элемент массива до тех пор, пока не находит искомый элемент или не достигает конца массива.

Анализ: Алгоритм проходит по всем элементам массива от начала до конца, сравнивая каждый элемент с целевыми значениями.

Цикл для достижения успеха от первого до последнего элемента массива. На каждой итерации сравнивается текущий элемент с целевыми значениями. В лучшем случае алгоритм находит элемент на первой позиции, в более позднем — на последней или не находит вообще.

Временная сложность: O(n)

Почему O(n): В максимально возможном случае алгоритму необходимо проверить все n элементов массива. В среднем случае примерно n/2 элементов.

Анализ алгоритма: Бинарный поиск (Binary Search) Определение: Бинарный поиск (Binary Search) — это алгоритм поиска, который работает на отсортированном массиве и многократно делит интервал поиска пополам, сравнивая средний элемент с целевыми значениями.

Анализ: Алгоритм начинает поиск со всего массива и на каждом шаге определяет интервал поиска в два раза.

Цикл пока выполняется тех пор, пока интервал измерения не сократится до нуля. На каждой итерации вычисляется средний элемент интервала и сравнивается с целевыми значениями. В зависимости от результата сравнения поиск продолжается в левом или правом часовом интервале.

Временная сложность: O(log n)

Почему O(log n): На каждом шаге алгоритм уменьшает область определения в два раза. Максимальное количество шагов, необходимое для нахождения элемента, равно log₂n, где n — размер массива.

Анализ алгоритма: Интерполяционный поиск (Интерполяционный поиск) Определение: Интерполяционный поиск (Интерполяционный поиск) — это алгоритм поиска в отсортированном массиве, который использует элементы значений для оценки вероятного положения иского элемента.

Анализ: Алгоритм вычисляет вычисляемую позицию элемента на основе значений целевого элемента и результатов на границах интервала определения.

Цикл, пока выполняется техзадание, до тех пор, пока интервал измерения не дотянется до нуля и выключится элемент, находящийся в пределах текущего интервала. На каждой итерации оценивается предполагаемая позиция с использованием интерполяционной формулы. В зависимости от результата сравнения поиск продолжается в левой или правой части интервала.

Временная сложность:

В среднем случае: O(log log n)

В худшем случае: O(n)

O(log log n) в среднем: Алгоритм эффективно обеспечивает область поиска на каждом этапе, особенно при распределении элементов, что приводит к логарифмическому от логарифма времени выполнения.

O(n) в исходном случае: При неравномерном распределении элементов алгоритм может деградировать до линейного поиска, если элементы распределены неравномерно.

Анализ алгоритма: Поиск Фибоначчи (Поиск Фибоначчи) Определение: Поиск Фибоначчи (Поиск Фибоначчи) — это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения позиций сравнения и деления массива.

Анализ: Алгоритм последовательно по последовательностям Фибоначчи до тех пор, пока не найдет число, большее или равное по размеру массива. Этот алгоритм использует числа Фибоначчи для определения сравнения позиций в массиве.

Первый цикл, пока ведутся числа Фибоначчи до достижения нужного размера. Второй цикл во время поиска проводится с использованием чисел Фибоначчи для определения позиций сравнения. На каждой итерации алгоритм определяет область определения базового эталонного элемента в вычисленной позиции с целевыми значениями.

Временная сложность: O(log n)

Почему O(log n): Алгоритмит массив на части, используя числа Фибоначчи, что обеспечивает логарифмическое время выполнения приведенного бинарного делительного поиска, но другим способом определения точки средней.
